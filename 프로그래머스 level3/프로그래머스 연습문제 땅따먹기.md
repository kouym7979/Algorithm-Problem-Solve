## 프로그래머스 연습문제 땅따먹기

###### 문제 설명

땅따먹기 게임을 하려고 합니다. 땅따먹기 게임의 땅(land)은 총 N행 4열로 이루어져 있고, 모든 칸에는 점수가 쓰여 있습니다. 1행부터 땅을 밟으며 한 행씩 내려올 때, 각 행의 4칸 중 한 칸만 밟으면서 내려와야 합니다. **단, 땅따먹기 게임에는 한 행씩 내려올 때, 같은 열을 연속해서 밟을 수 없는 특수 규칙이 있습니다.**

예를 들면,

| 1 | 2 | 3 | 5 |

| 5 | 6 | 7 | 8 |

| 4 | 3 | 2 | 1 |

로 땅이 주어졌다면, 1행에서 네번째 칸 (5)를 밟았으면, 2행의 네번째 칸 (8)은 밟을 수 없습니다.

마지막 행까지 모두 내려왔을 때, 얻을 수 있는 점수의 최대값을 return하는 solution 함수를 완성해 주세요. 위 예의 경우, 1행의 네번째 칸 (5), 2행의 세번째 칸 (7), 3행의 첫번째 칸 (4) 땅을 밟아 16점이 최고점이 되므로 16을 return 하면 됩니다.

##### 제한사항

- 행의 개수 N : 100,000 이하의 자연수
- 열의 개수는 4개이고, 땅(land)은 2차원 배열로 주어집니다.
- 점수 : 100 이하의 자연수

##### 입출력 예

| land                            | answer |
| ------------------------------- | ------ |
| [[1,2,3,5],[5,6,7,8],[4,3,2,1]] | 16     |

##### 입출력 예 설명

입출력 예 #1
문제의 예시와 같습니다.

___



```
#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>


using namespace std;

int dp[100001][4] = { 0 };

int solution(vector<vector<int> > land)
{
	int answer = 0;

	for (int k = 0; k < land.size(); k++) {
		int sum = 0;
		if (k == 0)
		{
			for (int x = 0; x < 4; x++)
			{
				dp[k][x] = land[k][x];//첫줄은 기존이랑 똑같이
			}
		}
		else {
			for (int i = 0; i < 4; i++)
			{
				for (int j = 0; j < 4; j++)//4열로 고정이므로
				{
					if (i != j)//이전과 같은 열인지
					{
						dp[k][i] = max(dp[k][i], land[k][i] + dp[k - 1][j]);
					}
				}
			}
		}
	}


	for (int j = 0; j < 4; j++)
	{
		answer = max(answer, dp[land.size() - 1][j]);
	}


	return answer;
}


```

___

문제해설 : 이번 문제는 동적계산법(DP)으로 접근해서 문제를 풀었습니다.

1. 각 칸에서 다음행과의 합중 최대값을 저장할 새로운 배열 dp를 만들어줍니다. 첫 행은 주어진 문제의 배열과 똑같이 할당해줍니다.
2. 문제에 제시된 조건인 이전의 열과 진행할 행에서 같은 열의 값을 더하지 못하므로 다른 열의 값만들 더해서 그중 최대값을 저장해줍니다. (이때, 저는 위에서 아래로 내려가는 방식이아닌 아래에서 위로 훑는 방식으로 진행했습니다.)
3. 위를 반복해줍니다.
4. dp배열이 완성되면 마지막행의 값중 최대값을 answer에 넣어주면 완료가 됩니다.



개인적으로 정말 어려웠던 문제였습니다...(왜 이게 level2에 있는것인지...) DP문제는 빠르게 방식을 캐치하지못하면 한없이 헤매게 되는 문제인것 같습니다 ㅜㅜ... 더욱 많은 문제를 풀어서 경험을 쌓도록 하겠습니다.



사용언어: c++

출처: https://programmers.co.kr/learn/courses/30/lessons/12913#qna