# SW코딩테스트 대비 1회차 1번문제

SW코딩테스트 대비 1번 문제는 2018년도 카카오 신입 공채 1차 코딩테스트 1번문제였습니다.



비상금을 숨겨놓은 장소를 알려줄 비밀지도를 해독하는 문제인데요. 

다음은 문제에대한 설명입니다.

1. 지도는 한 변의 길이가 `n`인 정사각형 배열 형태로, 각 칸은 “공백”(“ “) 또는 “벽”(“#”) 두 종류로 이루어져 있다.
2. 전체 지도는 두 장의 지도를 겹쳐서 얻을 수 있다. 각각 “지도 1”과 “지도 2”라고 하자. 지도 1 또는 지도 2 중 어느 하나라도 벽인 부분은 전체 지도에서도 벽이다. 지도 1과 지도 2에서 모두 공백인 부분은 전체 지도에서도 공백이다.
3. “지도 1”과 “지도 2”는 각각 정수 배열로 암호화되어 있다.
4. 암호화된 배열은 지도의 각 가로줄에서 벽 부분을 `1`, 공백 부분을 `0`으로 부호화했을 때 얻어지는 이진수에 해당하는 값의 배열이다.                             

---

저는 이 문제를 비트연산을 이용해서 풀어보았습니다.

다음은 이 문제에 대한 코드입니다.

'''

#include <iostream>
#include <algorithm>
#include <stdio.h>
#include "vector"

int n; //지도의 한번 크기
using namespace std;
vector<int> arr1;
vector<int> arr2;
vector<string>sol;

vector<string> binary(vector<int> a,vector<int> b,int n)
{
	
	vector<string> sum;
	
	for (int i = 0; i < n; i++)
	{
		string st = "";
		int tmp = a[i] | b[i];//비트연산 or연산
		for (int j = 0; j < n; j++) {
			if (tmp % 2 == 0)
				st += " ";
			else
				st += "#";
			tmp = tmp >> 1;//비트연산자 쉬프트 이동
		}
		reverse(st.begin(), st.end());//문자열을 역순으로 바꿔줌
		sum.push_back(st);//바뀐 문자열을 대입
	}
	return sum;
}


int main()
{
	
	int x;
	scanf("%d", &n);
	
	for (int i = 0; i < n; i++)
	{
		cin >> x;
		arr1.push_back(x);
	}
	
	for (int i = 0; i < n; i++)
	{
		scanf("%d", &x);
		arr2.push_back(x);
	}
	
	sol = binary(arr1, arr2, n);
	
	for (int i = 0; i < n; i++)
	{
		cout << sol[i]<<endl;
	}
	
	return 0;
}

'''