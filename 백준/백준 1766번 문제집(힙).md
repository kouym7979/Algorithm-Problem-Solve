## 백준 1766번 문제집(힙)

## 문제

민오는 1번부터 N번까지 총 N개의 문제로 되어 있는 문제집을 풀려고 한다. 문제는 난이도 순서로 출제되어 있다. 즉 1번 문제가 가장 쉬운 문제이고 N번 문제가 가장 어려운 문제가 된다.

어떤 문제부터 풀까 고민하면서 문제를 훑어보던 민오는, 몇몇 문제들 사이에는 '먼저 푸는 것이 좋은 문제'가 있다는 것을 알게 되었다. 예를 들어 1번 문제를 풀고 나면 4번 문제가 쉽게 풀린다거나 하는 식이다. 민오는 다음의 세 가지 조건에 따라 문제를 풀 순서를 정하기로 하였다.

1. N개의 문제는 모두 풀어야 한다.
2. 먼저 푸는 것이 좋은 문제가 있는 문제는, 먼저 푸는 것이 좋은 문제를 반드시 먼저 풀어야 한다.
3. 가능하면 쉬운 문제부터 풀어야 한다.

예를 들어서 네 개의 문제가 있다고 하자. 4번 문제는 2번 문제보다 먼저 푸는 것이 좋고, 3번 문제는 1번 문제보다 먼저 푸는 것이 좋다고 하자. 만일 4-3-2-1의 순서로 문제를 풀게 되면 조건 1과 조건 2를 만족한다. 하지만 조건 3을 만족하지 않는다. 4보다 3을 충분히 먼저 풀 수 있기 때문이다. 따라서 조건 3을 만족하는 문제를 풀 순서는 3-1-4-2가 된다.

문제의 개수와 먼저 푸는 것이 좋은 문제에 대한 정보가 주어졌을 때, 주어진 조건을 만족하면서 민오가 풀 문제의 순서를 결정해 주는 프로그램을 작성하시오.

## 입력

첫째 줄에 문제의 수 N(1 ≤ N ≤ 32,000)과 먼저 푸는 것이 좋은 문제에 대한 정보의 개수 M(1 ≤ M ≤ 100,000)이 주어진다. 둘째 줄부터 M개의 줄에 걸쳐 두 정수의 순서쌍 A,B가 빈칸을 사이에 두고 주어진다. 이는 A번 문제는 B번 문제보다 먼저 푸는 것이 좋다는 의미이다.

항상 문제를 모두 풀 수 있는 경우만 입력으로 주어진다.

## 출력

첫째 줄에 문제 번호를 나타내는 1 이상 N 이하의 정수들을 민오가 풀어야 하는 순서대로 빈칸을 사이에 두고 출력한다.

## 예제 입력 1 복사

```
4 2
4 2
3 1
```

## 예제 출력 1 복사

```
3 1 4 2
```

___

```
#include <algorithm>
#include <iostream>
#include <vector>
#include <string>
#include <queue>

//N은 문제의 수, M은 먼저 푸는 것이 좋은 문제에 대한 정보의 개수
using namespace std;

int main()
{
	int N, M, indegree[32001] = {0};//문제의 수와 정보의 개수
	int a, b;//a가 먼저 푸는 것이 좋은것 b가 그에 관련된 문제
	scanf("%d%d", &N, &M);
	priority_queue<int, vector<int>, greater<int>>sol;
	vector<int>node[32001];

	for (int i = 0; i < M; i++)
	{
		scanf("%d%d", &a, &b);
		node[a].push_back(b);
		indegree[b]++;
	}

	for (int i = 1; i <= N; i++)
	{
		if (indegree[i]==0)//indegree가 0인 문제들부터 넣는다.
			sol.push(i);
	}

	while (!sol.empty())
	{
		int cur = sol.top();//문제 번호가 낮은 순서부터
		sol.pop();
		cout << cur << " ";
		for (auto i:node[cur])
		{
			if (--indegree[i] == 0)//먼저 팝을 하고 검사하니까
				sol.push(i);
		}
	}
	

	return 0;
}
```

___

이 문제는 위상정렬의 개념을 토대로 우선순위 큐를 이용하여 풀어보았습니다.

위상정렬은 DAG에서 방향성을 거스르지않게 정점들을 나열하는 알고리즘이 위상정렬이라 합니다.

DAG는 Directed Acycle Graph의 줄임말인데 사이클이 없는 방향그래프를 의미합니다.

위상정렬을 구현하는 방법은 통상적으로 2가지가 있습니다. 첫번째는 DFS를 이용해서 구현하는 방식이고, indegree방식으로 구현하는 방식이 있습니다.  

저는 한 정점에서 자신에게 들어오는 방향의 간선의 수를 저장하는 방식인 indegree방식으로 위의 문제를 풀어보았습니다.

문제의 조건중에 하나의 문제를 풀때 우선적으로 풀어야 하는 문제가 있는 조건때문입니다. 이 조건을  풀어보면 한 문제의 여러가지 선행문제가 들어올 수 있기 때문입니다.

문제설명:

1.  정점에 들어오는 간선의 수를 저장할 indegree배열과 우선순위 큐, 그리고 간선을 나타낼 벡터를 선언합니다.
2. node벡터에 선행문제와 문제를 대입합니다. 그리고 문제번호에 해당하는 indegree를 증가시킵니다.
3. indegree가 0인 즉, 문제를 풀기에 앞서 선행 문제가 없는 문제들을 번호가 낮은것부터 큐에 넣습니다.
4. 이제 우선순위 큐가 다 빌때까지 차수를 감소시켜주며 auto문을 통해 간선을 연결한 점들을 큐에넣어줍니다.



사용언어: c++

출처:https://www.acmicpc.net/problem/1766