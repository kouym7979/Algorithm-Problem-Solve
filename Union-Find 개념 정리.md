# Union-Find 개념 정리

## **Disjoint Set의 개념**

**Disjoint Set이란**

서로 중복되지 않는 부분 집합들로 나눠진 원소들에 대한 정보를 저장하고 조작하는 자료구조

- 즉, 공통 원소가 없는, 즉 '상호 배타적'인 부분 집합들로 나눠진 원소들에 대한 자료구조이다.
- Disjoint Set=서로소 집합 자료구조



**Union-Find의 연산**

-  make-set(x)
  - 초기화
  - x를 유일한 원소로 하는 새로운 집합을 만든다.
- union(x,y)
  - 합하기
  - x가 속한 집합과 y가 속한 집합을 합친다. 즉, x와 y가 속한 두 집합을 합치는 연산
- find(x)
  - 찾기
  - x가 속한 집합의 대표값(루트 노드 값)을 반환한다. 즉, x가 어떤 집합에 속해 있는지 찾는 연산

## Union-find 알고리즘을 트리 구조로 구현하는 이유

1. 배열
   - Array[i]: i번 원소가 속하는 집합의 번호(즉, 루트 노드의 번호)
   - make-set(x)
     - Array[i]=i 와 같이 각자 다른 집합 번호로 초기화 한다.
   - union(x,y)
     - 배열의 모든 원소를 순회화면서 y의 집합 번호를 x의 집합 번호로 변경한다.
     - 시간 복잡도: O(N)
   - find(x)
     - 한 번만에 x가 속한 집합 번호를 찾는다.
     - 시간 복잡도: O(1)
2. 트리
   - 같은 집합=하나의 트리, 즉 집합 번호= 루트 노드
   - make-set(x)
     - 각 노드는 모두 루트 노드이므로 N개의 루트 노드 생성 및 자기 자신으로 초기화한다.
   - union(x,y)
     - x, y의 루트 노드를 찾고 다르면 y를 x의 자손으로 넣어 두 트리를 합한다.
     - 시간 복잡도: O(N)보다 작으므로 find 연산이 전체 수행 시긴을 지배한다.
   - find(x)
     - 노드의 집합 번호는 루트 노드이므로, 루트 노드를 확인하여 같은 집합인지 확인한다.
     - 시간 복잡도: 트리의 높이와 시간 복잡도가 동일하다. (최악: O(N-1))



### Union-find의 과정

![img](https://gmlwjd9405.github.io/images/algorithm-union-find/union-find-example.png)

